* lazy evalation: testen, in voorbeeld kijken of onnodige ifelsess gebeuren?
* relative guards
  Relative guarding: xab, a^b, maak er xac van, c is b of ^b en dus 1, dan met
  x^a, zou goed moeten gaan? Eerst niet doen! Depends on order? Probably not
* implementeer oblivious proxy/ensemble: _(obj), dereference with ._(),
  cartesisch product guards bij functietoepassing

* What to do if oblivious guard is not a bit?
* Use array indexing instead of get, set
* Deepcopy?

* make ctx, __guard accessible to code (ctx: turn into load_local and do not process, __guard: turn into load_local)

* documentatie 
  - behaviour on globals is undefined
  - for does not test oblivious initial conditions
  - implement bit assertions/conversions on guard

* for: generic iterator __nextcode__, make sure same iterator can be used in oblivious and non-oblivious code
* allerlei tests met f(x)==x.val if x:=oblif(f)(oblif(args)).val if isinstance(x,OblivVal) else x
* kijken of bij return de context triviaal is

Generieke obliv-wrap die alles doorgeeft aan zijn onderliggende value (modulo een paar optimalisaties)

Ook met spdz proberen?

Native variant met decorators? Toch over nadenken?

a and a, a or a: return self, is that required or just more efficient?

Oblif membrr funvtion; avoid deepcopy on self, use var_ to denote no use of ctx! Of standaard geen deepcopy kan ook! 

If then else lazy with ensemble: dict{id: guard} --> vermijd onnodig!