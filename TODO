* no special treatment for ret
* we willen eigenlijk wel dat in

   def fn(x)
     if x==4:
       a=4
     else
       a=5
     a=3 ... we hier weten dat de guard triviaal is... of maakt dat niet uit?

Refactoring
While compiling, print orig code, new code interleaved, start out with printing code and add our impl
Call(stack: 1 of tuple, argslist, ret: 0 1 or tuple)
Label returns false or stack, jumpiftrueorpop, jumpforward nextblock, jumplabel, unpack
Keep source and target stack sizes, assert correspondence
Comute stack size aa we go, if none then unreachable code
Call jmp, ..., or nojmp at end of block

Short-term
* does it work on lambda's?
* fix for and a break? 
* code coverage van tests bekijken
* wildgroei aan call-functies opschonen
* compute_stack_sizes werkt niet met unreachable code

Longer-term
* kijken of bij return de context triviaal is
* lazy evalation: testen, in voorbeeld kijken of onnodige ifelsess gebeuren?
* Switch naar bytecode controlflowgraph? Loops in termen daarvan detecteren?
* relative guards?
  Relative guarding: xab, a^b, maak er xac van, c is b of ^b en dus 1, dan met
  x^a, zou goed moeten gaan? Eerst niet doen! Depends on order? Probably not
* What to do if oblivious guard is not a bit?
* Use array indexing instead of get, set
* implementeer oblivious proxy/ensemble: _(obj), dereference with ._(),
  cartesisch product guards bij functietoepassing
* generieke obliv-wrap die alles doorgeeft aan zijn onderliggende value
  (modulo een paar optimalisaties)? kunnen we daar toch een impliciete
  deepcopy op doen?
* Ook met spdz proberen?
* Native variant met decorators? Toch over nadenken?


Document

Assumptions for programmer:
* No oblivious computations on immutables, globals
* For does not test oblivious initial conditions
* Encourage to submit functions where not the same
* Works on lambdas...

Assumptions for backends:
* Guard needs to be "binary" (|, &, 1-)
* Guard needs to support if_else
* Immutability, if_then_else idempotence: no longer needed?
* Note if_else acts on tuples
* a and a, a or a: return self, is that required or just more efficient?


