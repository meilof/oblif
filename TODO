* Can we try to avoid ifthenelse for guard and 1-guard?
  guard = ifthenelse(cond,__guard,0)
  guari = ifthenelse(cond,0,__guard)
  what will be called is guari.if_then_else(guari,guard)=ifthenelse(ifthenelse(cond,0,__guard),ifthenelse(cond,0,__guard),ifthenelse(cond,__guard,0)) => simplify this?
* Paar voorbeelden kijken of het aantal if_then_elses ongeveer klopt? Test case voor maken? Monkey-patchen?  https://stackoverflow.com/questions/22356914/using-python-mock-to-count-number-of-method-calls https://www.google.com/search?q=python+unittest+count+number+of+invocations&rlz=1C1GCEU_nlNL821NL821&oq=python+unittest+count+number+of+invocations&aqs=chrome..69i57.8112j1j7&sourceid=chrome&ie=UTF-8
* Add all examples from the docs to test cases
* Ranges voorwaarde hoeft niet cumulatief!
* Ranges: tuple doen voor patchen? Oblivious stride?
* Use ensemble at label level?

Longer-term
* code coverage van tests bekijken
* kijken of bij return de context triviaal is
* lazy evalation: testen, in voorbeeld kijken of onnodige ifelsess gebeuren?
* Switch naar bytecode controlflowgraph? Loops in termen daarvan detecteren?
* relative guards?
  Relative guarding: xab, a^b, maak er xac van, c is b of ^b en dus 1, dan met
  x^a, zou goed moeten gaan? Eerst niet doen! Depends on order? Probably not
* What to do if oblivious guard is not a bit?
* Use array indexing instead of get, set
* implementeer oblivious proxy/ensemble: _(obj), dereference with ._(),
  cartesisch product guards bij functietoepassing
* generieke obliv-wrap die alles doorgeeft aan zijn onderliggende value
  (modulo een paar optimalisaties)? kunnen we daar toch een impliciete
  deepcopy op doen?
* Ook met spdz proberen?
* Native variant met decorators? Toch over nadenken?


Document

Assumptions for programmer:
* No oblivious computations on immutables, globals
* For does not test oblivious initial conditions
* Encourage to submit functions where not the same
* Works on lambdas...

Assumptions for backends:
* Guard needs to be "binary" (|, &, 1-)
* Guard needs to support if_else
* Immutability, if_then_else idempotence: no longer needed?
* Note if_else acts on tuples
* a and a, a or a: return self, is that required or just more efficient?


